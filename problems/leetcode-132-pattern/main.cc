// https://leetcode.cn/problems/132-pattern/
// 456. 132 模式
// 给你一个整数数组 nums ，数组中共有 n 个整数。132 模式的子序列 由三个整数
// nums[i]、nums[j] 和 nums[k] 组成，并同时满足：i < j < k 和 nums[i] < nums[k]
// < nums[j] 。 如果 nums 中存在 132 模式的子序列 ，返回 true ；否则，返回 false
// 。
//
// 例子: 输入：nums = [1,2,3,4] 输出：false 解释：序列中不存在 132
// 模式的子序列。
//
// 例子: 输入：nums = [3,1,4,2] 输出：true 解释：序列中有 1 个 132
// 模式的子序列： [1, 4, 2] 。
//
// 例子: 输入：nums = [-1,3,2,0] 输出：true 解释：序列中有 3 个 132
// 模式的的子序列：[-1, 3, 2]、[-1, 3, 0] 和 [-1, 2, 0] 。

#include <stack>
#include <vector>
using namespace std;
class Solution {
   public:
    bool find132pattern(vector<int>& nums) {
        // 题目是 132 模式
        // 1是最小的元素，在最左边
        // 3是最大的元素，但是在中间
        // 所以这个问题，找 1 是最容易的
        // 也就是说，要迭代出来合适的 32 ，1 只要找 3 左边最小的一个就可以了
        // 所以，从右侧向左侧扫描
        // 采用从右向左行进的递减栈，但是和一般的单调栈模板不同之处在于:
        // 逼迫出栈的策略，分成两步进行:
        // 1. 先用更小的1来逼迫出栈
        // 2. 再用当前元素来逼迫出栈 (当然，这一步也不必进行，看下面代码)
        // 总而言之：
        // (3 作为行进元素，2 是栈内的任一元素, 1 是 3 左侧最小元素)
        // 这个题还可以变换到 (只要2不在中间)：
        // 231 模式，就会是：自左向右递减栈来扫描 (因为最小的1在最右侧)
        // 213 模式，就会是：自左向右递增栈来扫描 (因为最大的3在最右侧)
        // 312 模式，就会是：自右向左递增栈来扫描 (因为最大的3在最左侧)

        int n = nums.size();
        if (n < 3) return false;

        // L[i] 表示 i 左边（不包括i）的最小值, 也就是要找的 1
        vector<int> L(n, INT_MAX);
        for (int i = 1; i < n; i++) L[i] = std::min(L[i - 1], nums[i - 1]);

        // s 存的是元素的值, 单调递减栈
        stack<int> s;

        // 从右侧向左找
        for (int i = n - 1; i >= 1; i--) {
            if (nums[i] > L[i]) {
                // 先保证当前的 3 大于其左侧的最小值 1

                // 分批逼栈：

                // 因为 L[i] 更小，出栈条件比 nums[i] 更严格
                // 会把更小的出栈.
                // 比如说栈内最开始是 [5, 2] 可以然后用 L[i]=3
                // 去逼迫出栈，会变成是 [5]
                //
                // 接下来:
                //
                // 1. 如果要 push nums[i] 比栈顶更小，比如说是 4,
                // 则可以顺利入栈，仍然保持单调递减性质
                //
                // 2. 如果 push nums[i] 比栈顶更大 (严格更大)，比如说是 6,
                // 则就发现了 132 模式，直接 return true
                // (此时也来不及打破单调栈性质, 因为已经 return)
                //
                // 3. 如果 push nums[i] 和栈顶相等，比如说是 5, 直接 pop
                //
                // 所以, 总而言之，push(nums[i]) 后仍然可以维护住单调递减的性质
                // 总体来说，单调栈的模板没变, 计算点都在出栈之处
                while (!s.empty()) {
                    if (s.top() <= L[i])
                        // 比 L[i] 小的, 这部分会被先弹出去，因为是递减栈
                        s.pop();
                    else if (s.top() == nums[i])  // 等于 nums[i] 的
                        s.pop();
                    else if (s.top() < nums[i])  // 大于 L[i], 但是严格小于
                                                 // nums[i] 的，找到 132 模式
                        return true;
                    else  // 无元素可以 pop, break
                        break;
                }
                s.push(nums[i]);
            }
        }
        return false;
    }
};
